using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;

namespace NBearLite
{
    /// <summary>
    /// ReadOnly Active Record base class
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class ReadOnlyActiveRecord<T> : MarshalByRefObject, IReadOnlyRecord
        where T : class, new()
    {
        #region MarshalByRefObject members

        /// <summary>
        /// Obtains a lifetime service object to control the lifetime policy for this instance.
        /// </summary>
        /// <returns>
        /// An object of type <see cref="T:System.Runtime.Remoting.Lifetime.ILease"></see> used to control the lifetime policy for this instance. This is the current lifetime service object for this instance if one exists; otherwise, a new lifetime service object initialized to the value of the <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime"></see> property.
        /// </returns>
        /// <exception cref="T:System.Security.SecurityException">The immediate caller does not have infrastructure permission. </exception>
        /// <PermissionSet><IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="RemotingConfiguration, Infrastructure"/></PermissionSet>
        public override object InitializeLifetimeService()
        {
            return null;
        }

        #endregion

        #region Fields

        protected internal static Database db;
        protected internal static IQueryTable table;
        protected internal static System.Reflection.MemberInfo identyFieldMemberInfo;
        protected internal static bool isIdentyFieldAutoGenerated = false;
        protected internal static QueryColumn identyColumn;
        protected internal static ExpressionClip[] findFields;

        #endregion

        #region Static members

        public static void ChangeDbBinding(Database newDb)
        {
            Check.Require(newDb, "newDb");

            db = newDb;
        }

        /// <summary>
        /// Initializes the class.
        /// </summary>
        /// <param name="db">The db.</param>
        /// <param name="table">The table.</param>
        /// <param name="identyColumn">The identy column.</param>
        /// <param name="findFields">The find fields.</param>
        public static void Initialize(Database db, IQueryTable table, QueryColumn identyColumn, params ExpressionClip[] findFields)
        {
            if (ReadOnlyActiveRecord<T>.db == null)
            {
                Check.Require(db, "db");
                Check.Require(table, "table");

                findFields = GetFindFieldsIfNullOrEmpty(table, findFields);

                ReadOnlyActiveRecord<T>.findFields = findFields;

                ReadOnlyActiveRecord<T>.db = db;
                ReadOnlyActiveRecord<T>.table = table;
                GetIdentyFieldInfo(out ReadOnlyActiveRecord<T>.identyFieldMemberInfo, out ReadOnlyActiveRecord<T>.isIdentyFieldAutoGenerated);

                if (ExpressionClip.IsNullOrEmpty(identyColumn) && ReadOnlyActiveRecord<T>.identyFieldMemberInfo != null)
                {
                    foreach (ExpressionClip column in findFields)
                    {
                        if (column.ToString().Split('.')[1] == "[" + ReadOnlyActiveRecord<T>.identyFieldMemberInfo.Name + "]")
                        {
                            identyColumn = (QueryColumn)column;
                            break;
                        }
                    }
                }

                Check.Require(!ExpressionClip.IsNullOrEmpty(identyColumn), "identyColumn could not be null or empty.");

                ReadOnlyActiveRecord<T>.identyColumn = identyColumn;
            }
        }

        private static ExpressionClip[] GetFindFieldsIfNullOrEmpty(IQueryTable table, ExpressionClip[] findFields)
        {
            if (findFields == null || findFields.Length == 0)
            {
                PropertyInfo[] pis = table.GetType().GetProperties();
                if (pis != null && pis.Length > 0)
                {
                    List<ExpressionClip> findFieldsList = new List<ExpressionClip>();
                    for (int i = 0; i < pis.Length; ++i)
                    {
                        if (typeof(T).GetProperty(pis[i].Name) != null || typeof(T).GetField(pis[i].Name) != null)
                            findFieldsList.Add((ExpressionClip)pis[i].GetValue(table, null));
                    }
                    findFields = findFieldsList.ToArray();
                }
                else
                    findFields = new ExpressionClip[] { QueryColumn.All() };
            }

            return findFields;
        }

        /// <summary>
        /// Initializes the class.
        /// </summary>
        /// <param name="db">The db.</param>
        /// <param name="table">The table.</param>
        public static void Initialize(Database db, IQueryTable table)
        {
            Initialize(db, table, null);
        }

        /// <summary>
        /// Ensures the class is initialized.
        /// </summary>
        public static void EnsureInitialized()
        {
            if (ReadOnlyActiveRecord<T>.db == null)
                new T();   //initialize an instance of this active record to ensure the static constructor is called.

            Check.Require(db != null && table != null && (!ExpressionClip.IsNullOrEmpty(identyColumn)),
                "The ReadOnlyActiveRecord must be initialized first.");
        }

        private static void GetIdentyFieldInfo(out System.Reflection.MemberInfo field, out bool isAutoGenerated)
        {
            foreach (System.Reflection.PropertyInfo pi in ReflectionUtils.DeepGetProperties(typeof(T)))
            {
                PrimaryKeyAttribute pka = AttributeUtils.GetAttribute<PrimaryKeyAttribute>(pi);
                if (pka != null)
                {
                    field = pi;
                    isAutoGenerated = pka.IsAutoGenerated;
                    return;
                }
            }

            foreach (System.Reflection.FieldInfo fi in ReflectionUtils.DeepGetFields(typeof(T)))
            {
                PrimaryKeyAttribute pka = AttributeUtils.GetAttribute<PrimaryKeyAttribute>(fi);
                if (pka != null)
                {
                    field = fi;
                    isAutoGenerated = pka.IsAutoGenerated;
                    return;
                }
            }

            isAutoGenerated = false;

            //pick the first property or field as the identy field of this active record
            foreach (System.Reflection.MemberInfo mi in typeof(T).GetMembers())
            {
                if (mi is System.Reflection.PropertyInfo)
                {
                    System.Reflection.PropertyInfo pi = mi as System.Reflection.PropertyInfo;
                    if (pi.CanRead && pi.CanWrite)
                    {
                        field = pi;
                        return;
                    }
                }
                else if (mi is System.Reflection.FieldInfo)
                {
                    field = mi;
                    return;
                }
            }

            field = null;
        }

        /// <summary>
        /// Counts all.
        /// </summary>
        /// <returns></returns>
        public static int CountAll()
        {
            EnsureInitialized();

            return db.Select(table, QueryColumn.All().Count()).ToScalar<int>();
        }

        /// <summary>
        /// Counts the specified where.
        /// </summary>
        /// <param name="where">The where.</param>
        /// <returns></returns>
        public static int Count(WhereClip where)
        {
            EnsureInitialized();

            return db.Select(table, QueryColumn.All().Count()).Where(where).ToScalar<int>();
        }

        /// <summary>
        /// Existses the specified id.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <returns></returns>
        public static bool Exists(object id)
        {
            EnsureInitialized();

            int retCount = Count(identyColumn == id);
            Check.Ensure(retCount < 2, "Duplicated objects with same id value exist, please check your data store.");

            return retCount == 1;
        }

        /// <summary>
        /// Finds all.
        /// </summary>
        /// <param name="orderBys">The order bys.</param>
        /// <returns></returns>
        public static List<T>FindAll(params OrderByClip[] orderBys)
        {
            EnsureInitialized();

            return db.Select(table, findFields).OrderBy(orderBys).ToList<T>();
        }

        /// <summary>
        /// Finds the specified where.
        /// </summary>
        /// <param name="where">The where.</param>
        /// <param name="orderBys">The order bys.</param>
        /// <returns></returns>
        public static List<T>Find(WhereClip where, params OrderByClip[] orderBys)
        {
            EnsureInitialized();

            return db.Select(table, findFields).Where(where).OrderBy(orderBys).ToList<T>();
        }

        /// <summary>
        /// Finds the page.
        /// </summary>
        /// <param name="pageSize">Size of the page.</param>
        /// <param name="pageNo">The page no.</param>
        /// <param name="orderBys">The order bys.</param>
        /// <returns></returns>
        public static List<T>FindPage(int pageSize, int pageNo, params OrderByClip[] orderBys)
        {
            EnsureInitialized();

            Check.Require(pageSize > 0 && pageNo > 0, "pageSize and pageNo must > 0");

            return db.Select(table, findFields).OrderBy(orderBys).SetSelectRange(pageSize, pageSize * (pageNo - 1), identyColumn).ToList<T>();
        }

        /// <summary>
        /// Finds the page.
        /// </summary>
        /// <param name="pageSize">Size of the page.</param>
        /// <param name="pageNo">The page no.</param>
        /// <param name="where">The where.</param>
        /// <param name="orderBys">The order bys.</param>
        /// <returns></returns>
        public static List<T>FindPage(int pageSize, int pageNo, WhereClip where, params OrderByClip[] orderBys)
        {
            EnsureInitialized();

            Check.Require(pageSize > 0 && pageNo > 0, "pageSize and pageNo must > 0");

            return db.Select(table, findFields).Where(where).OrderBy(orderBys).SetSelectRange(pageSize, pageSize * (pageNo - 1), identyColumn).ToList<T>();
        }

        /// <summary>
        /// Finds the top.
        /// </summary>
        /// <param name="topCount">The top count.</param>
        /// <param name="orderBys">The order bys.</param>
        /// <returns></returns>
        public static List<T>FindTop(int topCount, params OrderByClip[] orderBys)
        {
            EnsureInitialized();

            Check.Require(topCount, "topCount must > 0");

            return db.Select(table, findFields).OrderBy(orderBys).SetSelectRange(topCount, 0, identyColumn).ToList<T>();
        }

        /// <summary>
        /// Finds the top.
        /// </summary>
        /// <param name="topCount">The top count.</param>
        /// <param name="where">The where.</param>
        /// <param name="orderBys">The order bys.</param>
        /// <returns></returns>
        public static List<T>FindTop(int topCount, WhereClip where, params OrderByClip[] orderBys)
        {
            EnsureInitialized();

            Check.Require(topCount, "topCount must > 0");

            return db.Select(table, findFields).Where(where).OrderBy(orderBys).SetSelectRange(topCount, 0, identyColumn).ToList<T>();
        }

        /// <summary>
        /// Finds the first.
        /// </summary>
        /// <param name="where">The where.</param>
        /// <param name="orderBys">The order bys.</param>
        /// <returns></returns>
        public static T FindFirst(WhereClip where, params OrderByClip[] orderBys)
        {
            EnsureInitialized();

            return db.Select(table, findFields).Where(where).OrderBy(orderBys).ToSingleObject<T>();
        }

        /// <summary>
        /// Finds the by id.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <returns></returns>
        public static T FindById(object id)
        {
            EnsureInitialized();

            return db.Select(table, findFields).Where(identyColumn == id).ToSingleObject<T>();
        }

        /// <summary>
        /// Finds the scalar.
        /// </summary>
        /// <param name="returnColumn">The return column.</param>
        /// <param name="where">The where.</param>
        /// <returns></returns>
        public static ReturnType FindScalar<ReturnType>(ExpressionClip returnColumn, WhereClip where)
        {
            return db.Select(table, returnColumn).Where(where).ToScalar<ReturnType>();
        }

        /// <summary>
        /// Finds the scalar by id.
        /// </summary>
        /// <param name="returnColumn">The return column.</param>
        /// <param name="id">The id.</param>
        /// <returns></returns>
        public static ReturnType FindScalarById<ReturnType>(ExpressionClip returnColumn, object id)
        {
            return FindScalar<ReturnType>(returnColumn, identyColumn == id);
        }

        #endregion

        #region Nonstatic members

        /// <summary>
        /// Refreshes this instance.
        /// </summary>
        public virtual void Refresh()
        {
            System.Data.IDataReader reader = db.Select(table, findFields).Where(identyColumn == ReflectionUtils.GetFieldValue(this, identyFieldMemberInfo)).ToDataReader();
            if (reader.Read())
            {
                NBear.Mapping.ObjectConvertor.ToObject<System.Data.IDataReader, T>(reader, (T)((object)this));
            }
        }

        /// <summary>
        /// Existses this instance.
        /// </summary>
        /// <returns></returns>
        public virtual bool Exists()
        {
            return Exists(ReflectionUtils.GetFieldValue(this, identyFieldMemberInfo));
        }

        #endregion
    }

    /// <summary>
    /// Active Record base class.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class ActiveRecord<T> : ReadOnlyActiveRecord<T>, IRecord
        where T : class, new()
    {
        #region Fields

        protected internal static IQueryTable writeTable;
        protected internal static ActiveRecordFieldList createFields;
        protected internal static ActiveRecordFieldList updateFields;
        protected internal static Dictionary<string, string> contantCreateFieldExpressions = new Dictionary<string, string>();
        protected internal static Dictionary<string, string> contantUpdateFieldExpressions = new Dictionary<string, string>();

        #endregion

        #region Static members

        /// <summary>
        /// Initializes the class.
        /// </summary>
        /// <param name="db">The db.</param>
        /// <param name="readTable">The read table.</param>
        /// <param name="identyColumn">The identy column.</param>
        /// <param name="createFields">The create fields.</param>
        /// <param name="updateFields">The update fields.</param>
        /// <param name="findFields">The find fields.</param>
        public static void Initialize(Database db, IQueryTable readTable, QueryColumn identyColumn,
            ActiveRecordFieldList createFields, ActiveRecordFieldList updateFields, params ExpressionClip[] findFields)
        {
            Initialize(db, readTable, readTable, identyColumn, createFields, updateFields, findFields);
        }

        /// <summary>
        /// Initializes the class.
        /// </summary>
        /// <param name="db">The db.</param>
        /// <param name="readTable">The read table.</param>
        /// <param name="writeTable">The write table.</param>
        /// <param name="identyColumn">The identy column.</param>
        /// <param name="createFields">The create fields.</param>
        /// <param name="updateFields">The update fields.</param>
        /// <param name="findFields">The find fields.</param>
        public static void Initialize(Database db, IQueryTable readTable, IQueryTable writeTable, QueryColumn identyColumn,
            ActiveRecordFieldList createFields, ActiveRecordFieldList updateFields, params ExpressionClip[] findFields)
        {
            ReadOnlyActiveRecord<T>.Initialize(db, readTable, identyColumn, findFields);
            ActiveRecord<T>.writeTable = writeTable ?? readTable;

            if (ActiveRecord<T>.createFields == null || createFields.Fields.Count == 0)
            {
                createFields = GetCreateOrUpdateFieldsIfNullOrEmpty(writeTable, createFields);
                if (updateFields == null || updateFields.Fields.Count == 0)
                    updateFields = createFields;

                Check.Require(createFields, "createFields");
                Check.Require(updateFields, "updateFields");

                foreach (KeyValuePair<string, QueryColumn> item in createFields.Fields)
                {
                    MemberInfo mi = (MemberInfo)typeof(T).GetProperty(item.Key) ?? (MemberInfo)typeof(T).GetField(item.Key);
                    ConstantCreateExpressionAttribute constExpr = AttributeUtils.GetAttribute<ConstantCreateExpressionAttribute>(mi);
                    if (constExpr != null)
                        contantCreateFieldExpressions.Add(item.Key, constExpr.Expression);
                }

                foreach (KeyValuePair<string, QueryColumn> item in updateFields.Fields)
                {
                    MemberInfo mi = (MemberInfo)typeof(T).GetProperty(item.Key) ?? (MemberInfo)typeof(T).GetField(item.Key);
                    ConstantUpdateExpressionAttribute constExpr = AttributeUtils.GetAttribute<ConstantUpdateExpressionAttribute>(mi);
                    if (constExpr != null)
                        contantUpdateFieldExpressions.Add(item.Key, constExpr.Expression);
                }

                ActiveRecord<T>.createFields = createFields;
                ActiveRecord<T>.updateFields = updateFields;
            }
        }

        private static ActiveRecordFieldList GetCreateOrUpdateFieldsIfNullOrEmpty(IQueryTable table, ActiveRecordFieldList createOrUpdate)
        {
            if (createOrUpdate == null || createOrUpdate.Fields.Count == 0)
            {
                PropertyInfo[] pis = table.GetType().GetProperties();
                if (pis != null && pis.Length > 0)
                {
                    createOrUpdate = new ActiveRecordFieldList();
                    for (int i = 0; i < pis.Length; ++i)
                    {
                        if (!(ReadOnlyActiveRecord<T>.isIdentyFieldAutoGenerated && pis[i].Name == identyFieldMemberInfo.Name))
                            if ((typeof(T).GetProperty(pis[i].Name) != null || typeof(T).GetField(pis[i].Name) != null))
                                createOrUpdate.Add(pis[i].Name, (QueryColumn)pis[i].GetValue(table, null));
                    }
                }
            }

            return createOrUpdate;
        }

        /// <summary>
        /// Initializes the class.
        /// </summary>
        /// <param name="db">The db.</param>
        /// <param name="readTable">The read table.</param>
        /// <param name="identyColumn">The identy column.</param>
        /// <param name="createAndUpdateFields">The create and update fields.</param>
        /// <param name="findFields">The find fields.</param>
        public static void Initialize(Database db, IQueryTable readTable, QueryColumn identyColumn,
            ActiveRecordFieldList createAndUpdateFields, params ExpressionClip[] findFields)
        {
            Initialize(db, readTable, identyColumn, createAndUpdateFields, createAndUpdateFields, findFields);
        }

        /// <summary>
        /// Initializes the class.
        /// </summary>
        /// <param name="db">The db.</param>
        /// <param name="table">The table.</param>
        new public static void Initialize(Database db, IQueryTable readTable)
        {
            Initialize(db, readTable, null, null);
        }

        /// <summary>
        /// Ensures the class is initialized.
        /// </summary>
        new public static void EnsureInitialized()
        {
            ReadOnlyActiveRecord<T>.EnsureInitialized();

            Check.Require(findFields != null && createFields != null && updateFields != null,
                "The ActiveRecord must be initialized first.");
        }

        /// <summary>
        /// Deletes all.
        /// </summary>
        /// <returns></returns>
        public static int DeleteAll()
        {
            EnsureInitialized();

            return db.Delete(writeTable).Execute();
        }

        /// <summary>
        /// Deletes the specified where.
        /// </summary>
        /// <param name="where">The where.</param>
        /// <returns></returns>
        public static int Delete(WhereClip where)
        {
            EnsureInitialized();

            return db.Delete(writeTable).Where(where).Execute();
        }

        #endregion

        #region Nonstatic members

        protected void DoCreate(System.Data.Common.DbTransaction tran, ActiveRecordFieldList specifiedFieldsToCreate)
        {
            InsertSqlSection insert = db.Insert(writeTable).SetTransaction(tran);

            foreach (KeyValuePair<string, QueryColumn> field in specifiedFieldsToCreate.Fields)
            {
                if (contantCreateFieldExpressions.ContainsKey(field.Key))
                    insert.AddColumn(field.Value, new ExpressionClip(contantCreateFieldExpressions[field.Key], field.Value.DbType, null, null, null));
                else
                {
                    PropertyInfo pi = ReflectionUtils.DeepGetProperty(this.GetType(), field.Key);
                    object entityFieldValue = pi.GetValue(this, null);
                    if (AttributeUtils.GetAttribute<NBearLite.PrimaryKeyAttribute>(pi) == null || (!CommonUtils.IsEqual(entityFieldValue, CommonUtils.DefaultValue(pi.PropertyType))))
                        insert.AddColumn(field.Value, entityFieldValue);
                }
            }

            if ((!ExpressionClip.IsNullOrEmpty(identyColumn)) && ReadOnlyActiveRecord<T>.isIdentyFieldAutoGenerated && ReadOnlyActiveRecord<T>.identyFieldMemberInfo != null)
            {
                object val = insert.ExecuteReturnAutoIncrementID(identyColumn);

                //set the autogenrated field value
                if (ReadOnlyActiveRecord<T>.identyFieldMemberInfo is System.Reflection.PropertyInfo)
                {
                    System.Reflection.PropertyInfo pi = (System.Reflection.PropertyInfo)(ReadOnlyActiveRecord<T>.identyFieldMemberInfo);
                    Type fieldType = pi.PropertyType;
                    if (fieldType != typeof(int))
                        val = Convert.ChangeType(val, fieldType);
                    pi.SetValue(this, val, null);
                }
                else
                {
                    System.Reflection.FieldInfo fi = (System.Reflection.FieldInfo)(ReadOnlyActiveRecord<T>.identyFieldMemberInfo);
                    Type fieldType = fi.FieldType;
                    if (fieldType != typeof(int))
                        val = Convert.ChangeType(val, fieldType);
                    fi.SetValue(this, val);
                }
            }
            else
            {
                insert.Execute();
            }
        }

        protected void DoUpdate(System.Data.Common.DbTransaction tran, ActiveRecordFieldList specifiedFieldsToUpdate)
        {
            Check.Require(specifiedFieldsToUpdate != null && specifiedFieldsToUpdate.Fields.Count > 0,
                "specifiedFieldsToUpdate could not be null or empty.");

            UpdateSqlSection update = db.Update(writeTable).SetTransaction(tran);

            foreach (KeyValuePair<string, QueryColumn> field in specifiedFieldsToUpdate.Fields)
            {
                if (contantUpdateFieldExpressions.ContainsKey(field.Key))
                    update.AddColumn(field.Value, new ExpressionClip(contantUpdateFieldExpressions[field.Key], field.Value.DbType, null, null, null));
                else if (identyColumn.ToString() != field.Value.ToString())
                    update.AddColumn(field.Value, ReflectionUtils.GetFieldValue(this, field.Key));
            }

            update.Where(identyColumn == ReflectionUtils.GetFieldValue(this, identyFieldMemberInfo));

            int retVal = update.Execute();

            if (retVal < 1)
                throw new NoRecordUpdatedException(string.Format("table = {0}, id = {1}", writeTable.ToString(), ReflectionUtils.GetFieldValue(this, identyFieldMemberInfo)));
        }

        protected void DoDelete(System.Data.Common.DbTransaction tran)
        {
            DeleteSqlSection delete = db.Delete(writeTable);

            delete.Where(identyColumn == ReflectionUtils.GetFieldValue(this, identyFieldMemberInfo));

            int retVal = delete.Execute();

            if (retVal < 1)
                throw new NoRecordDeletedException(string.Format("table = {0}, id = {1}", writeTable.ToString(), ReflectionUtils.GetFieldValue(this, identyFieldMemberInfo)));
        }

        /// <summary>
        /// Creates this instance.
        /// </summary>
        public void Create()
        {
            Create(new string[0]);
        }

        /// <summary>
        /// Creates the specified fields to create.
        /// </summary>
        /// <param name="specifiedFieldsToCreate">The specified fields to create.</param>
        public void Create(params string[] specifiedFieldsToCreate)
        {
            ActiveRecordFieldList list = ActiveRecordFieldList.FilterSpecifiedFields(ActiveRecord<T>.createFields, specifiedFieldsToCreate);
            
            Check.Assert(list.Fields.Count > 0, "No valid fields to create specified.");

            Create(null, list);
        }

        /// <summary>
        /// Creates the instance.
        /// </summary>
        /// <param name="tran">The tran.</param>
        public void Create(System.Data.Common.DbTransaction tran)
        {
            Create(tran, new string[0]);
        }

        /// <summary>
        /// Creates the instance.
        /// </summary>
        /// <param name="tran">The tran.</param>
        /// <param name="specifiedFieldsToCreate">The specified fields to create.</param>
        public void Create(System.Data.Common.DbTransaction tran, params string[] specifiedFieldsToCreate)
        {
            ActiveRecordFieldList list = ActiveRecordFieldList.FilterSpecifiedFields(ActiveRecord<T>.createFields, specifiedFieldsToCreate);
            
            Check.Assert(list.Fields.Count > 0, "No valid fields to create specified.");

            Create(tran, list);
        }

        protected virtual void Create(System.Data.Common.DbTransaction tran, ActiveRecordFieldList specifiedFieldsToCreate)
        {
            DoCreate(tran, specifiedFieldsToCreate);
        }

        /// <summary>
        /// Updates this instance.
        /// </summary>
        public void Update()
        {
            Update(new string[0]);
        }

        /// <summary>
        /// Updates the specified fields to update.
        /// </summary>
        /// <param name="specifiedFieldsToUpdate">The specified fields to update.</param>
        public void Update(params string[] specifiedFieldsToUpdate)
        {
            ActiveRecordFieldList list = ActiveRecordFieldList.FilterSpecifiedFields(ActiveRecord<T>.updateFields, specifiedFieldsToUpdate);

            Check.Assert(list.Fields.Count > 0, "No valid fields to update specified.");

            Update(null, list);
        }

        /// <summary>
        /// Updates this instance.
        /// </summary>
        /// <param name="tran">The tran.</param>
        public void Update(System.Data.Common.DbTransaction tran)
        {
            Update(tran, new string[0]);
        }

        /// <summary>
        /// Updates this instance.
        /// </summary>
        /// <param name="tran">The tran.</param>
        /// <param name="specifiedFieldsToUpdate">The specified fields to update.</param>
        public void Update(System.Data.Common.DbTransaction tran, params string[] specifiedFieldsToUpdate)
        {
            ActiveRecordFieldList list = ActiveRecordFieldList.FilterSpecifiedFields(ActiveRecord<T>.updateFields, specifiedFieldsToUpdate);

            Check.Assert(list.Fields.Count > 0, "No valid fields to update specified.");

            Update(tran, list);
        }

        protected virtual void Update(System.Data.Common.DbTransaction tran, ActiveRecordFieldList specifiedFieldsToUpdate)
        {
            DoUpdate(tran, specifiedFieldsToUpdate);
        }

        /// <summary>
        /// Deletes the instance.
        /// </summary>
        /// <param name="tran">The tran.</param>
        public virtual void Delete(System.Data.Common.DbTransaction tran)
        {
            DoDelete(tran);
        }

        /// <summary>
        /// Deletes this instance.
        /// </summary>
        public void Delete()
        {
            Delete((System.Data.Common.DbTransaction)null);
        }

        /// <summary>
        /// Saves this instance.
        /// </summary>
        public void Save()
        {
            Save(null);
        }

        /// <summary>
        /// Deletes this instance.
        /// </summary>
        /// <param name="tran">The tran.</param>
        public virtual void Save(System.Data.Common.DbTransaction tran)
        {
            if (Exists())
                Update(tran);
            else
                Create(tran);
        }

        #endregion
    }

    /// <summary>
    /// The ActiveRecordFieldList class.
    /// </summary>
    public sealed class ActiveRecordFieldList
    {
        internal readonly List<KeyValuePair<string, QueryColumn>> Fields = new List<KeyValuePair<string, QueryColumn>>();

        /// <summary>
        /// Adds the specified field name.
        /// </summary>
        /// <param name="fieldName">Name of the field.</param>
        /// <param name="mappingColumn">The mapping column.</param>
        /// <returns></returns>
        public ActiveRecordFieldList Add(string fieldName, QueryColumn mappingColumn)
        {
            Check.Require(fieldName, "fieldName", Check.NotNullOrEmpty);
            Check.Require(mappingColumn, "mappingColumn");

            Fields.Add(new KeyValuePair<string, QueryColumn>(fieldName, mappingColumn));

            return this;
        }

        /// <summary>
        /// Removes the specified field name.
        /// </summary>
        /// <param name="fieldName">Name of the field.</param>
        /// <returns></returns>
        public ActiveRecordFieldList Remove(string fieldName)
        {
            Check.Require(fieldName, "fieldName", Check.NotNullOrEmpty);

            foreach (KeyValuePair<string, QueryColumn> field in Fields)
            {
                if (field.Key == fieldName)
                {
                    Fields.Remove(field);
                    return this;
                }
            }

            return this;
        }

        /// <summary>
        /// Filters the specified fields.
        /// </summary>
        /// <param name="baseList">The base list.</param>
        /// <param name="specifiedFieldsToFilter">The specified fields to filter.</param>
        /// <returns></returns>
        public static ActiveRecordFieldList FilterSpecifiedFields(ActiveRecordFieldList baseList, string[] specifiedFieldsToFilter)
        {
            Check.Require(baseList, "baseList");

            ActiveRecordFieldList list = new ActiveRecordFieldList();
            if (specifiedFieldsToFilter != null && specifiedFieldsToFilter.Length > 0)
            {
                List<string> specifiedFieldsToCreateList = CommonUtils.ToObjectList<string>(specifiedFieldsToFilter.GetEnumerator());
                foreach (KeyValuePair<string, QueryColumn> field in baseList.Fields)
                {
                    if (specifiedFieldsToCreateList.Contains(field.Key))
                        list.Fields.Add(field);
                }
            }
            else
                list = baseList;

            return list;
        }

    }

    [Serializable, AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
    public sealed class PrimaryKeyAttribute : Attribute
    {
        private bool isAutoGenerated = false;

        public bool IsAutoGenerated
        {
            get
            {
                return this.isAutoGenerated;
            }
        }

        public PrimaryKeyAttribute()
        {
        }

        public PrimaryKeyAttribute(bool isAutoGenerated)
        {
            this.isAutoGenerated = isAutoGenerated;
        }
    }

    [Serializable, AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
    public sealed class ConstantCreateExpressionAttribute : Attribute
    {
        private string expr;

        public string Expression
        {
            get
            {
                return this.expr;
            }
        }

        public ConstantCreateExpressionAttribute(string expr)
        {
            Check.Require(expr, "expr");

            this.expr = expr;
        }
    }

    [Serializable, AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
    public sealed class ConstantUpdateExpressionAttribute : Attribute
    {
        private string expr;

        public string Expression
        {
            get
            {
                return this.expr;
            }
        }

        public ConstantUpdateExpressionAttribute(string expr)
        {
            Check.Require(expr, "expr");

            this.expr = expr;
        }
    }

    public static class CommonConstantExpressions
    {
        public const string GET_UTC_DATE = "GETUTCDATE()";
        public const string GET_DATE = "GETDATE()";
    }

#if DEBUG

    public class SampleActiveRecord : ActiveRecord<SampleActiveRecord>
    {
        #region Sample db, table and columns

        public static Database SampleDatabase = null;
        public static IQueryTable SampleTable = new CustomQueryTable("SampleTable");
        public static QueryColumn SampleTable_ID = new QueryColumn("ID", System.Data.DbType.Int32);
        public static QueryColumn SampleTable_Name = new QueryColumn("Name", System.Data.DbType.String);

        #endregion

        static SampleActiveRecord()
        {
            Initialize(
                SampleDatabase,   //The Database object bound with this ActiveRecord
                SampleTable, //The table bound with this ActiveRecord
                SampleTable_ID,    //The identy column bound with this ActiveRecord
                new ActiveRecordFieldList().Add("ID", SampleTable_ID).Add("Name", SampleTable_Name),     //The fields to create
                new ActiveRecordFieldList().Add("Name", SampleTable_Name),  //The fields to update
                SampleTable_ID, SampleTable_Name  //The fields to find, if do not specify,  * will be returned
            );
        }

        [PrimaryKey(true)]
        public int ID;
        public string Name;
    }

#endif
}
